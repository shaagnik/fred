# FRED - a genetic music composer

## About

This is an experimental personal project written in python that generates musical compositions using a genetic algorithm. You must have [`music21`](https://web.mit.edu/music21/) installed to run it. After installing `music21`, simply run `python main.py` to initiate a run. Configuration values are, as of now, all stored within `weights.py`

The music generated by this software is bizarre and often abrasive, but manipulating the parameters can lead to some interesting output. The goal here is not to coax a computer into creating a brilliant masterpiece to rival human composers, but rather to inspire human composers by sparking imagination with off-kilter, unlikely patterns and melodies that remain 'musical'. 

## How It Works

The program generates randomized, four part piano compositions. It then assigns each piece a fitness score (based on a set of weights, detailed below), and randomly selects the fittest individuals to 'mate'. The mating process outputs a new generation of pieces, which then are fed through the same steps. After a set number of generations, the fitness score has ideally increased, and the final 'best' piece is shaped by the weight parameters - leading to a new piece of music a human would be extremely unlikely to create.

### Generating a Piece

The pieces are generated to fit within certain parameters. The ranges for the four piano voices are set to traditional human vocal ranges (bass, tenor, alto, soprano), and each voice is generated as a random series of tones selected from its respective range. The notes are also given random durations (quarter, half, dotted half, whole), with a random chance to be a rest. The program generates four voices of the same length (set in the `piece_length` variable) and combines them into one piece for analysis. The pieces are thus all within the western 12TET tonal system and with relatively limited rhythmic variation. These constraints are temporary - an attempt to define the data space more concretely before expanding into more instruments, rhythms, tonalities and so forth.

### Scoring

The scoring system is, admittedly, arbitrary. I have endeavored to create a system that scores the relationships between each note in the piece, rather than any macroscopic or more traditional musical analysis. Each interval is given a weight - today based entirely on my own tinkering and experimentation, and summed to find the piece's score.

The process is as follows:
- Each voice is given a 'horizontal' score - each note's relationship to its successive note is tabulated.
	- Each voice is further weighted by its position - a different weight for the lowest, highest, etc.
- Each beat is given a 'vertical' score - each note's relationship to the lowest voice is tabulated.
- These scores are averaged (with the vertical score being somewhat more important) to return the final piece score

#### Issues

My scoring approach is far from rigorous - it is somewhat arbitrary by design. I intend to catalog as many dimensions for differentiating pieces as possible, without imposing my own biases on 'what is important'.

The weights, on the other hand, are completely decided by personal preference and creativity, though a future project for generating the weights is detailed below. For my purposes, I've attempted to nudge the random pieces toward having major chords and stepwise melodies.

### Mating

The mating process is simply selecting two random members of the generation - weighted by their fitness score - and then combining them in the simplest way possible. The first half of the first parent is attached to the second half of the second parent. This potentially retains some of the features that gave the parent a high fitness score to begin with. Finally, a random selection of notes are mutated - transposed either up or down by one or two half steps. This represents the random mutation chance in sexual reproduction, and the mechanism for introducing new features to the population.


### Output

While running, the program indicates which generation is being created. 

Every 100 generations, it outputs to the command line: 
- the current top score
- change from the last time it reported
- how many successive generations have seen an increased score

Finally, it writes that top scoring composition to a file called `top.mid`, which the user can periodically listen to to see how things are progressing.

## Future Work

There are a lot of places I'd like to expand this project, in four main areas:

### Generating

`music21` is an extremely powerful library that this project uses a very small subset of. The generated pieces could easily move beyond simple 'piano chorales' to include drums, strings, or any other instruments. The library also includes chords, slurs, and other musical elements that could greatly expand the possibilities FRED currently affords.

Furthermore, the rhythmic range allowed by only four different durations is obviously limited, for ease of scoring. This could be expanded into wildly more diverse compositions, and certainly create some patterns humans are unlikely to.

### Scoring

There are many more dimensions to measure each piece on that are as yet unimplemented. Durations are largely untouched, and I'd like the horizontal interval weights to be tied to specific voices in a matrix. Using traditional musical analysis may also add to the process - determining the key and scoring based on adherence to functional harmony, but that seems limiting in this context.

### Weights

The weights are currently assigned arbitrarily based on my own experimentation. The goal, however, is to generate these weights programmatically using a corpus of existing music. This way, a run of the program could be tuned to highly score compositions that 'sound like a Bach fugue,' or whatever training set is used to define the weights. 

Ideally, the weights and scoring could be entirely obfuscated by a neural net implementation - an AI could develop a scoring system based on training data (like the aforementioned Bach fugues), then use that as the fitness function of the genetic algorithm.

### UI

As it stands, there is essentially no UI for this project. Everything is manipulated within the code. I'd like to build an interface with which a user can tweak the parameter values more intuitively. Ideally, some optimization could make the generations much faster and have real-time feedback to different parameters.

## Files

`main.py` - the script that runs the full procedure
`generator.py` - contains methods for generating the voices, pieces, and children
`genetics.py` - handles each generation - scoring each piece and choosing the parents
`weights.py` - contains the scoring system and all configuration values.

The `samples` folder contains sample midi files of a few of my results.

## Thank You

Thank you for checking out this project, please reach out if you'd like to know more!